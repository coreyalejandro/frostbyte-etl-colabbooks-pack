---
phase: 03-audit-stream-and-document-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/architecture/AUDIT_ARCHITECTURE.md
autonomous: true

must_haves:
  truths:
    - "The audit event schema includes concrete field definitions, event types, and a hash chain design that an engineer could implement as a database migration"
    - "The immutable storage design specifies the append-only mechanism (triggers, grants, or storage engine), tamper evidence approach, and the exact PostgreSQL DDL or equivalent"
    - "Audit query patterns cover the three primary auditor workflows (by tenant, by document, by time range) with example queries and export format specification"
  artifacts:
    - path: "docs/architecture/AUDIT_ARCHITECTURE.md"
      provides: "Complete audit stream architecture: schema, immutable storage, query patterns"
      contains: "Audit Event Schema"
      min_lines: 400
  key_links:
    - from: "docs/architecture/AUDIT_ARCHITECTURE.md"
      to: "docs/product/PRD.md Section 2, Appendix A"
      via: "Event schema and types align with PRD audit event specification"
      pattern: "event_type|event_id|previous_event_id"
    - from: "docs/architecture/AUDIT_ARCHITECTURE.md"
      to: "docs/product/PRD.md Section 5.7"
      via: "Query patterns implement Audit API endpoints"
      pattern: "GET.*audit|export|chain"
---

<objective>
Write the complete audit stream architecture document: event schema with hash chain, immutable storage design with PostgreSQL DDL, and auditor query patterns with example queries and export format.

Purpose: Phase 3 requires that implementation plans (Phases 4–7) can reference a concrete audit design. This document specifies the event schema, storage mechanism, and query patterns so engineers can implement audit emission and querying without interpretation.

Output: `docs/architecture/AUDIT_ARCHITECTURE.md` — a standalone architecture specification covering AUDIT-01, AUDIT-02, AUDIT-03.
</objective>

<execution_context>
@/Users/coreyalejandro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coreyalejandro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@docs/product/PRD.md (Section 2 audit schema, Appendix A event types, Section 5.7 Audit API)
@.planning/research/ARCHITECTURE.md (Audit Stream Architecture)
@.planning/phases/03-audit-stream-and-document-safety/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write audit event schema with field definitions and hash chain</name>
  <files>docs/architecture/AUDIT_ARCHITECTURE.md</files>
  <action>
Create `docs/architecture/AUDIT_ARCHITECTURE.md` with the following structure:

**Document header:**
- Title: "Audit Stream Architecture"
- Document version, created date, requirement traceability (AUDIT-01, AUDIT-02, AUDIT-03)
- Document conventions: notation for SQL, JSON, API paths

**Section 1: Audit Event Schema (AUDIT-01)**

1.1 Field definitions:
- Provide a complete table of every field with: name, type, required/optional, description, validation rules
- Fields: event_id (UUID v7), tenant_id, event_type, timestamp, actor, resource_type, resource_id, details (JSONB), previous_event_id
- details sub-fields: component, input_hash, output_hash, pipeline_version, duration_ms, status, plus event-type-specific fields (e.g., pii_types for PII_DETECTED, injection_score for POLICY_GATE_FAILED)

1.2 Event type enum:
- List all 24+ event types from PRD Appendix A, grouped by phase (Intake, Parsing, Policy, Embedding, Serving, Tenant Lifecycle)
- For each: event_type string, resource_type, typical details fields

1.3 Hash chain design:
- Explain previous_event_id linkage: each event (for document/chunk resources) links to the preceding event in the provenance chain
- Diagram (Mermaid) showing chain: DOCUMENT_INGESTED -> DOCUMENT_PARSED -> POLICY_GATE_PASSED -> DOCUMENT_EMBEDDED -> INDEX_WRITTEN
- Hash continuity rule: event N's input_hash must equal event N-1's output_hash
- Document the chain verification logic (pseudocode or SQL)
- Tenant lifecycle events: typically previous_event_id = null (no chain)

1.4 JSON schema:
- Include a complete JSON Schema or representative JSON example for a full chain (at least 3 linked events)

**Section 2: Immutable Storage Design (AUDIT-02)**

2.1 Append-only mechanism:
- PostgreSQL: REVOKE UPDATE, DELETE on audit_events from application role
- Document the exact GRANT structure: who can INSERT, who can SELECT
- Optional: BEFORE UPDATE OR DELETE trigger that raises exception (defense in depth)
- Offline mode: SQLite with same schema; file-level integrity (SHA-256 in export manifest)

2.2 Tamper evidence:
- Hash chain integrity: broken input_hash/output_hash continuity indicates tampering
- Optional: periodic chain hash signing (e.g., sign concatenation of event_ids in order) for external verification
- Document what "tamper evidence" means: detection, not prevention (append-only prevents modification; chain enables detection of gaps)

2.3 PostgreSQL DDL:
- Complete CREATE TABLE statement for audit_events with:
  - Columns matching schema (event_id UUID PRIMARY KEY, tenant_id TEXT NOT NULL, event_type TEXT NOT NULL, timestamp TIMESTAMPTZ NOT NULL, actor TEXT, resource_type TEXT, resource_id TEXT, details JSONB, previous_event_id UUID REFERENCES audit_events(event_id))
  - Indexes: (tenant_id, timestamp), (tenant_id, resource_id, timestamp), (event_type, timestamp)
  - Table partitioning recommendation for scale (by timestamp month) — optional
- Complete GRANT/REVOKE statements for append-only semantics
- Optional: CREATE TRIGGER to block UPDATE/DELETE

2.4 Offline mode storage:
- SQLite schema (same columns, SQLite types)
- Export format: JSON Lines, one event per line, with manifest containing SHA-256 of export file
  </action>
  <verify>
1. grep -c "event_id\|tenant_id\|event_type\|previous_event_id" docs/architecture/AUDIT_ARCHITECTURE.md >= 15
2. grep -c "CREATE TABLE\|REVOKE\|GRANT\|INSERT" docs/architecture/AUDIT_ARCHITECTURE.md >= 5
3. grep -c "mermaid" docs/architecture/AUDIT_ARCHITECTURE.md >= 1
4. wc -l docs/architecture/AUDIT_ARCHITECTURE.md >= 250
  </verify>
  <done>
Section 1 and 2 complete. Event schema has all fields, event types, and hash chain design. Immutable storage has PostgreSQL DDL with grants and optional trigger. Tamper evidence approach documented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write audit query patterns and export specification</name>
  <files>docs/architecture/AUDIT_ARCHITECTURE.md</files>
  <action>
Add the following sections to the existing `docs/architecture/AUDIT_ARCHITECTURE.md`:

**Section 3: Audit Query Patterns (AUDIT-03)**

3.1 Workflow 1 — By tenant:
- Use case: "Show me all events for tenant X in the last 30 days"
- Example SQL query with parameter placeholders
- Example API call: GET /api/v1/audit/{tenant_id}/events?from=...&to=...&limit=1000
- Response format: paginated list of events
- Index usage: (tenant_id, timestamp)

3.2 Workflow 2 — By document:
- Use case: "Show me the full provenance chain for document file_001"
- Example SQL: recursive CTE or iterative query walking previous_event_id from DOCUMENT_INGESTED to INDEX_WRITTEN
- Example API call: GET /api/v1/audit/{tenant_id}/chain/file_001
- Response format: ordered list of events (oldest first)
- Chain integrity check: for each consecutive pair, verify event[i].input_hash == event[i-1].output_hash; report any breaks
- Pseudocode for chain verification

3.3 Workflow 3 — By time range:
- Use case: "Export all events for tenant X between date A and date B for compliance evidence"
- Example SQL query
- Example API call: POST /api/v1/audit/{tenant_id}/export with body {from, to, event_types?, format}
- Response: asynchronous; returns job_id or download URL when ready

3.4 Export format specification:
- JSON Lines: one JSON object per line, UTF-8 encoded
- Each line: complete audit event as stored
- File naming: audit_export_{tenant_id}_{from}_{to}.jsonl
- Manifest: JSON file with export_metadata (tenant_id, from, to, event_count, file_sha256, exported_at)
- SIEM integration notes: common fields for Splunk/Elastic/syslog (optional subsection)

3.5 Pagination and limits:
- Default page size: 100 events
- Max page size: 1000
- Cursor-based pagination: use event_id + timestamp as cursor
- Rate limits: 300 req/min per tenant for audit API (from PRD)
  </action>
  <verify>
1. grep -c "BY tenant\|BY document\|BY time\|workflow\|Workflow" docs/architecture/AUDIT_ARCHITECTURE.md >= 5
2. grep -c "SELECT\|FROM audit\|WHERE" docs/architecture/AUDIT_ARCHITECTURE.md >= 8
3. grep -c "export\|Export\|jsonl\|JSON Lines" docs/architecture/AUDIT_ARCHITECTURE.md >= 5
4. wc -l docs/architecture/AUDIT_ARCHITECTURE.md >= 400
  </verify>
  <done>
Section 3 complete. Three auditor workflows with example queries. Export format specified (JSON Lines + manifest). API endpoints referenced.
  </done>
</task>

</tasks>

<verification>
After both tasks, verify against ROADMAP Phase 3 success criteria:
1. Audit event schema: concrete field definitions, event types, hash chain — implementable as DB migration ✓
2. Immutable storage: append-only mechanism, tamper evidence, exact PostgreSQL DDL ✓
3. Audit query patterns: by tenant, by document, by time range with example queries and export format ✓
</verification>

<success_criteria>
- docs/architecture/AUDIT_ARCHITECTURE.md exists with >= 400 lines
- Complete event schema with all fields and event types from PRD Appendix A
- Hash chain design with diagram and verification logic
- PostgreSQL DDL with CREATE TABLE, indexes, GRANT/REVOKE
- Three query patterns with example SQL and API calls
- Export format (JSON Lines + manifest) specified
</success_criteria>

<output>
After completion, create `.planning/phases/03-audit-stream-and-document-safety/03-01-SUMMARY.md`
</output>
