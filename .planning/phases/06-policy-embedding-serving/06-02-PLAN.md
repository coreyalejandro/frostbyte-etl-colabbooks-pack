---
phase: 06-policy-embedding-serving
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/EMBEDDING_INDEXING_PLAN.md
autonomous: true

must_haves:
  truths:
    - "The embedding plan specifies both OpenRouter (online) and Nomic (offline) integration, including model version recording, dimension assertions, and the vector write flow to Qdrant"
  artifacts:
    - path: "docs/EMBEDDING_INDEXING_PLAN.md"
      provides: "Step-by-step embedding and indexing implementation plan"
      min_lines: 400
---

<objective>
Create the embedding and indexing implementation plan: OpenRouter (online) and Nomic (offline) integration, model version recording, 768d dimension assertion, three-store write (object, relational, vector), retry/rollback. An engineer must execute without clarifying questions.

Output: `docs/EMBEDDING_INDEXING_PLAN.md`
</objective>

<context>
@docs/PRD.md (Section 2.4 Phase D)
@docs/TECH_DECISIONS.md (OpenRouter, Nomic, 768d lock)
@docs/AUDIT_ARCHITECTURE.md (DOCUMENT_EMBEDDED, INDEX_WRITTEN, EMBEDDING_FAILED)
@docs/STORAGE_LAYER_PLAN.md (Qdrant, PostgreSQL, MinIO)
</context>

<tasks>
<task type="auto">
  <name>Write embedding and indexing plan</name>
  <files>docs/EMBEDDING_INDEXING_PLAN.md</files>
  <action>
Create docs/EMBEDDING_INDEXING_PLAN.md with: (1) Input: policy-approved chunks; (2) Online: OpenRouter text-embedding-3-small dimensions=768, API call pattern; (3) Offline: Nomic embed-text v1.5 via local container, 768d native; (4) Dimension assertion: reject if != 768; (5) Three-store write: object (verify canonical exists), relational (chunk metadata), vector (Qdrant with chunk_id, metadata filters); (6) Write integrity verification, rollback on mismatch; (7) Index metadata record schema; (8) Retry (10s, 60s, 300s), DLQ on failure; (9) Audit events; (10) Mode parity and divergence (semantic difference between models)
  </action>
</task>
</tasks>

<output>
Create 06-02-SUMMARY.md
</output>
