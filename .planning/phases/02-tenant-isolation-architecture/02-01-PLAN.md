---
phase: 02-tenant-isolation-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/TENANT_ISOLATION_HETZNER.md
autonomous: true

must_haves:
  truths:
    - "An engineer reading only TENANT_ISOLATION_HETZNER.md can execute the full Hetzner provisioning sequence (server, network, firewall, volume) for a new tenant without consulting any other document or asking clarifying questions"
    - "Every Hetzner API call in the provisioning sequence includes the HTTP method, endpoint path, request body with all required fields, expected response status, and expected response fields"
    - "Network boundary rules are specified as concrete firewall rules (allow/deny, direction, protocol, port, source/destination CIDR) for both Hetzner Cloud mode and Docker Compose offline mode"
    - "Cross-tenant traffic denial is provable: the document specifies how to verify that Tenant A cannot reach Tenant B's network, with concrete verification commands"
    - "The document covers both provisioning and deprovisioning of Hetzner resources, matching the PRD Section 3.4 and 3.6 sequences"
  artifacts:
    - path: "docs/TENANT_ISOLATION_HETZNER.md"
      provides: "Complete Hetzner provisioning specification and network boundary rules"
      contains: "Provisioning Sequence"
      min_lines: 400
  key_links:
    - from: "docs/TENANT_ISOLATION_HETZNER.md"
      to: "docs/PRD.md Section 3.4"
      via: "Provisioning sequence steps 1-3, 6-11 mapped to concrete Hetzner API calls"
      pattern: "PRD.*3\\.4|provisioning.*step"
    - from: "docs/TENANT_ISOLATION_HETZNER.md"
      to: "docs/TECH_DECISIONS.md"
      via: "References hcloud SDK >=2.10, server types, network zones"
      pattern: "hcloud|cx22|nbg1"
    - from: "docs/TENANT_ISOLATION_HETZNER.md"
      to: "docs/PRD.md Section 3.6"
      via: "Deprovisioning steps 6-7 (compute + network resource deletion)"
      pattern: "deprovision|delete.*server|delete.*network|delete.*firewall"
---

<objective>
Write the complete Hetzner Cloud provisioning specification and network boundary rules document for per-tenant isolation.

Purpose: Phase 2 requires that implementation plans (Phases 4-7) can reference concrete provisioning sequences and network rules. This document specifies exactly how to provision and deprovision Hetzner Cloud resources for a tenant, and exactly what firewall rules enforce network isolation -- eliminating all ambiguity about the infrastructure layer.

Output: `docs/TENANT_ISOLATION_HETZNER.md` -- a standalone architecture specification document covering ISOL-01 (Hetzner provisioning) and ISOL-04 (network boundary specification).
</objective>

<execution_context>
@/Users/coreyalejandro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coreyalejandro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 outputs (required references)
@docs/PRD.md (Section 3.4: Provisioning Actions Detail, Section 3.5: Kill-Switch, Section 3.6: Deprovisioning Actions Detail)
@docs/TECH_DECISIONS.md (Component #2: Hetzner Cloud, Component #33: hcloud SDK >=2.10, Component #7: Docker Compose >=2.29)

# Phase 2 research (verified patterns and pitfalls)
@.planning/phases/02-tenant-isolation-architecture/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Hetzner provisioning sequence and compute/network/volume specifications</name>
  <files>docs/TENANT_ISOLATION_HETZNER.md</files>
  <action>
Create `docs/TENANT_ISOLATION_HETZNER.md` with the following structure and content:

**Document header:**
- Title: "Tenant Isolation: Hetzner Cloud Provisioning and Network Boundaries"
- Document version, created date, requirement traceability (ISOL-01, ISOL-04)
- Document conventions section explaining notation for API calls, firewall rules, and verification commands

**Section 1: Provisioning Sequence Overview**
- Map PRD Section 3.4 steps to concrete Hetzner API calls
- For each step, specify: step number, action description, online mode implementation, offline mode equivalent
- Include a Mermaid sequence diagram showing the full provisioning flow with rollback paths
- Specify the order constraint: network MUST be created before servers (servers reference network_id), firewall MUST be created before or alongside servers

**Section 2: Compute Provisioning (Step 2 from PRD 3.4)**
- Server creation API call: `POST /servers` with complete request body
  - `name`: `tenant-{tenant_id}-{role}-{index}` naming convention
  - `server_type`: `cx22` (2 vCPU, 4GB RAM) as default worker, `cx32` (4 vCPU, 8GB RAM) for heavy workloads
  - `image`: `ubuntu-22.04`
  - `location`: `nbg1` (Nuremberg, eu-central zone)
  - `labels`: `{"tenant_id": "{tenant_id}", "environment": "production", "role": "{worker|gateway|db}"}`
  - `networks`: `[{network_id}]`
  - `firewalls`: `[{"firewall": {firewall_id}}]`
  - `ssh_keys`: `[{ssh_key_id}]`
- Expected response: 201 with server object (id, name, public_net, private_net, status)
- Polling for server readiness: `GET /servers/{id}` until `status == "running"`
- Label-based resource filtering: `GET /servers?label_selector=tenant_id={tenant_id}`
- Server type recommendations table (role -> server_type -> vCPU -> RAM -> rationale)
- Offline mode equivalent: Docker Compose service definitions with `deploy.resources.limits` for CPU/memory

**Section 3: Network Provisioning (Step 3 from PRD 3.4)**
- Private network creation: `POST /networks` with complete request body
  - `name`: `tenant-{tenant_id}-private`
  - `ip_range`: `10.{tenant_octet}.0.0/16` where tenant_octet is derived from tenant sequence number (1-254)
  - `labels`: `{"tenant_id": "{tenant_id}"}`
  - Subnet: `{"type": "cloud", "ip_range": "10.{tenant_octet}.1.0/24", "network_zone": "eu-central"}`
- Expected response: 201 with network object
- CIDR allocation scheme: document the tenant_octet derivation formula, the 254-tenant limit per /8 block, and the escape hatch (multiple /8 blocks)
- Note the Hetzner 100-server-per-network limit from research (Pitfall 2)
- CIDR normalization requirement from research (Pitfall 1): always use `ipaddress.ip_network(cidr, strict=False)`
- Offline mode equivalent: Docker Compose `networks` with `internal: true`, `driver: bridge`, `ipam` config

**Section 4: Volume Provisioning (Step 5 from PRD 3.4, mapped to Hetzner volumes)**
- Volume creation: `POST /volumes` with complete request body
  - `name`: `tenant-{tenant_id}-data`
  - `size`: 100 GB default (configurable per tenant)
  - `location`: `nbg1`
  - `labels`: `{"tenant_id": "{tenant_id}"}`
  - `format`: `ext4`
- Volume attachment to server: `POST /volumes/{id}/actions/attach` with `{"server": {server_id}}`
- Mount path convention: `/mnt/tenant-data`
- Offline mode equivalent: Docker Compose named volumes with size limits

**Section 5: DNS Configuration (Step 8 from PRD 3.4)**
- DNS record pattern: `{tenant_id}.pipeline.frostbyte.io` -> tenant API endpoint IP
- Hetzner does not provide DNS API -- specify external DNS provider integration point
- Health check URL: `https://{tenant_id}.pipeline.frostbyte.io/health`
- Offline mode: N/A (localhost access via port mapping)

**Section 6: Tenant Registry Integration (Step 9 from PRD 3.4)**
- SQL INSERT statement for tenant registration with all fields
- Audit event emission: `TENANT_PROVISIONED` event with provisioning details
- Health verification sequence: check each provisioned resource responds

**Section 7: Deprovisioning Sequence**
- Map PRD Section 3.6 steps 6-7 and 9 to concrete Hetzner API calls
- Server deletion: `DELETE /servers/{id}` with graceful shutdown first (`POST /servers/{id}/actions/shutdown`)
- Network deletion: `DELETE /networks/{id}` (must detach all servers first)
- Firewall deletion: `DELETE /firewalls/{id}` (must remove all resource associations first)
- Volume deletion: `POST /volumes/{id}/actions/detach` then `DELETE /volumes/{id}`
- DNS record removal
- Verification at each step: expected response codes and how to confirm deletion
- Rollback handling: what to do if a step fails mid-deprovisioning

Important constraints:
- Every API call must include the full HTTP method, path, request body, expected response status, and key response fields
- Use the hcloud Python SDK examples alongside raw API calls (both representations)
- Reference PRD Section 3.4 step numbers explicitly so future phases can trace back
- Include the CIDR normalization utility function from research Pitfall 1
- Document the implicit outbound ACCEPT behavior of Hetzner firewalls (research Pitfall 4)
- Do NOT include storage provisioning details (MinIO, PostgreSQL, Qdrant) -- those belong in Plan 02-02
  </action>
  <verify>
Verify the document:
1. `grep -c "POST\|GET\|DELETE\|PUT" docs/TENANT_ISOLATION_HETZNER.md` returns >= 15 (at least 15 API call references)
2. `grep -c "tenant_id" docs/TENANT_ISOLATION_HETZNER.md` returns >= 20 (tenant_id appears throughout)
3. `grep -c "10\.\|CIDR\|ip_range" docs/TENANT_ISOLATION_HETZNER.md` returns >= 10 (network addressing is concrete)
4. `grep -c "PRD.*3\\.4\|PRD.*3\\.6\|Section 3" docs/TENANT_ISOLATION_HETZNER.md` returns >= 3 (PRD cross-references exist)
5. `wc -l docs/TENANT_ISOLATION_HETZNER.md` returns >= 400
6. `grep -c "mermaid" docs/TENANT_ISOLATION_HETZNER.md` returns >= 1 (at least one diagram)
  </verify>
  <done>
Sections 1-7 are complete with full API call specifications, CIDR allocation scheme, volume provisioning, DNS pattern, deprovisioning sequence, and Mermaid provisioning flow diagram. Every API call has method, path, body, expected response. PRD 3.4 and 3.6 steps are explicitly cross-referenced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write network boundary specification with concrete firewall rules</name>
  <files>docs/TENANT_ISOLATION_HETZNER.md</files>
  <action>
Add the following sections to the existing `docs/TENANT_ISOLATION_HETZNER.md`:

**Section 8: Hetzner Cloud Firewall Rules (ISOL-04 — Online Mode)**

Create the firewall specification as a complete rule table. For each rule, specify:
- Rule name (human-readable identifier)
- Direction (in/out)
- Protocol (tcp/udp/icmp)
- Port (specific port or "any")
- Source IPs (CIDR) or Destination IPs (CIDR)
- Description (why this rule exists)

The firewall rules must cover:

8.1 Inbound Rules:
- ALLOW inbound HTTPS (443/tcp) from API gateway IP only (`{api_gateway_ip}/32`)
- ALLOW inbound SSH (22/tcp) from control plane bastion IP only (`{bastion_ip}/32`) -- for provisioning and maintenance
- ALLOW inbound all TCP from tenant's own private network (`10.{tenant_octet}.0.0/16`)
- DENY all other inbound (implicit -- Hetzner default when inbound rules exist)

8.2 Outbound Rules (CRITICAL -- document research Pitfall 4: implicit outbound ACCEPT):
- ALLOW outbound HTTPS (443/tcp) to OpenRouter API CIDR (online mode embedding API)
- ALLOW outbound all TCP to tenant's own private network (`10.{tenant_octet}.0.0/16`)
- ALLOW outbound DNS (53/tcp+udp) to Hetzner DNS resolvers (`185.12.64.1/32`, `185.12.64.2/32`)
- DENY all other outbound (implicit -- triggered by having at least one outbound rule defined)

8.3 Cross-tenant denial proof:
- Tenant A's firewall only allows source/destination within `10.A.0.0/16`
- Tenant B's network is `10.B.0.0/16` -- structurally unreachable
- Verification command: from Tenant A server, `curl -m 5 10.B.1.1:443` must timeout/fail
- Label selector application: firewall applies to all resources with `tenant_id={tenant_id}` label

8.4 Firewall creation API call:
- `POST /firewalls` with complete request body including all rules from 8.1 and 8.2
- Apply to resources: `POST /firewalls/{id}/actions/apply_to_resources` with label selector
- Expected responses for both calls
- hcloud Python SDK equivalent code

8.5 Firewall update procedure:
- Adding a rule: `POST /firewalls/{id}/actions/set_rules` (replaces all rules -- must include existing rules)
- Removing a rule: same endpoint with rule omitted
- Verification after update: `GET /firewalls/{id}` and inspect rules array

**Section 9: Docker Network Isolation (ISOL-04 — Offline Mode)**

9.1 Docker Compose network configuration:
- Complete `networks:` section with `internal: true`, `driver: bridge`
- IPAM configuration: `subnet: 172.28.0.0/16`, `gateway: ""` (no gateway = no outbound)
- Explain why `internal: true` provides structural isolation (no default gateway configured on the bridge)

9.2 Service-to-network mapping:
- Table showing each service and which network(s) it connects to
- All ETL services on `etl-internal` (internal: true)
- Only the intake gateway gets a port mapping to `127.0.0.1:8080:8080` for local access

9.3 Verification commands:
- `docker network inspect {network_name}` -- verify `Internal: true` and no gateway
- `docker exec {container} ip route` -- verify no default route
- `docker exec {container} ping -c 1 8.8.8.8` -- must fail (no route to host)
- `docker exec {container} ping -c 1 {other_service}` -- must succeed (inter-container communication works)

9.4 Comparison table: Hetzner Cloud vs Docker offline isolation mechanisms

**Section 10: Isolation Verification Runbook**

A step-by-step runbook that an engineer can execute to verify tenant isolation is working:

10.1 Online mode verification:
- Step 1: List all resources for tenant via label selector, verify all have correct tenant_id
- Step 2: From tenant server, attempt to reach another tenant's private IP -- must fail
- Step 3: From tenant server, attempt to reach internet (non-allowed destination) -- must fail
- Step 4: From tenant server, reach services within tenant network -- must succeed
- Step 5: Verify firewall rules match specification via `GET /firewalls/{id}`

10.2 Offline mode verification:
- Step 1: Verify network is `internal: true` via `docker network inspect`
- Step 2: Verify no default route in containers via `ip route`
- Step 3: Verify outbound connectivity blocked via `ping 8.8.8.8`
- Step 4: Verify inter-container connectivity via service name resolution

10.3 Verification evidence format:
- JSON structure for storing verification results (pass/fail, timestamp, command output)
- This format is referenced by the audit system for compliance evidence

Important constraints:
- Firewall rules must be concrete CIDRs, not placeholders -- use the `10.{tenant_octet}.0.0/16` pattern with explicit examples (e.g., Tenant A = `10.1.0.0/16`, Tenant B = `10.2.0.0/16`)
- Document the critical Hetzner firewall behavior: default outbound is ACCEPT; defining ONE outbound rule switches to implicit deny
- Include both raw API format and hcloud Python SDK format for firewall creation
- Docker offline section must show a complete, valid docker-compose.yml `networks:` fragment
  </action>
  <verify>
Verify the additions:
1. `grep -c "ALLOW\|DENY\|allow\|deny" docs/TENANT_ISOLATION_HETZNER.md` returns >= 10 (concrete firewall rules)
2. `grep -c "direction.*in\|direction.*out\|inbound\|outbound" docs/TENANT_ISOLATION_HETZNER.md` returns >= 8 (both directions covered)
3. `grep -c "internal.*true\|internal: true" docs/TENANT_ISOLATION_HETZNER.md` returns >= 3 (Docker internal network referenced)
4. `grep -c "verification\|verify\|Verify" docs/TENANT_ISOLATION_HETZNER.md` returns >= 10 (verification methods throughout)
5. `grep -c "cross-tenant\|cross.tenant\|Tenant A.*Tenant B" docs/TENANT_ISOLATION_HETZNER.md` returns >= 3 (cross-tenant denial documented)
6. `wc -l docs/TENANT_ISOLATION_HETZNER.md` returns >= 600 (total document with both tasks)
7. `grep "implicit.*deny\|implicit.*ACCEPT\|default.*outbound" docs/TENANT_ISOLATION_HETZNER.md` returns at least 1 match (Pitfall 4 documented)
  </verify>
  <done>
Sections 8-10 are complete. Hetzner Cloud firewall rules cover all inbound/outbound rules with concrete CIDRs and cross-tenant denial proof. Docker offline mode specifies `internal: true` network with verification commands. The isolation verification runbook provides step-by-step commands for both online and offline modes. The critical implicit outbound ACCEPT behavior is documented.
  </done>
</task>

</tasks>

<verification>
After both tasks, verify the complete document against Phase 2 success criteria:

1. **ISOL-01 coverage:** The document includes a step-by-step Hetzner provisioning sequence with specific API calls, parameters, and expected responses for server, network, firewall, and volume creation
2. **ISOL-04 coverage:** Network boundary rules are specified as concrete firewall rules (allow/deny, source, destination, port) for both Hetzner Cloud and Docker network modes
3. **PRD traceability:** PRD Section 3.4 steps are mapped to concrete Hetzner API calls; PRD Section 3.6 deprovisioning steps are mapped to deletion API calls
4. **Cross-tenant denial:** The document proves that Tenant A cannot reach Tenant B through structural network isolation (separate CIDRs + firewall rules)
5. **Offline mode parity:** Every online mode specification has an offline mode equivalent or explicit "N/A" with rationale
6. **Verification methods:** Every provisioned resource has a verification command to confirm correct state
</verification>

<success_criteria>
- docs/TENANT_ISOLATION_HETZNER.md exists with >= 600 lines
- Document covers ISOL-01 (Hetzner provisioning) and ISOL-04 (network boundaries)
- Every API call has method, path, body, expected response
- Firewall rules table has concrete CIDRs for both inbound and outbound
- Cross-tenant denial is structurally proven with verification commands
- Both online (Hetzner Cloud) and offline (Docker Compose) modes are specified
- Deprovisioning sequence with verification at each step
- Isolation verification runbook with step-by-step commands
</success_criteria>

<output>
After completion, create `.planning/phases/02-tenant-isolation-architecture/02-01-SUMMARY.md`
</output>
