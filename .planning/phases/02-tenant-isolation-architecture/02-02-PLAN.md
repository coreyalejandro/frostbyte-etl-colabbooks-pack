---
phase: 02-tenant-isolation-architecture
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md
autonomous: true

must_haves:
  truths:
    - "For every stateful component (MinIO, PostgreSQL, Qdrant, Redis), the document specifies the exact isolation mechanism, credential scope, provisioning commands, and a verification method that proves isolation works"
    - "The encryption key management design covers the complete lifecycle: key generation, envelope encryption workflow, per-tenant key-to-resource mapping, rotation procedure with backup safety, and key revocation"
    - "An engineer can provision a new tenant's storage layer (all four stores) by following the document alone, without consulting any other source"
    - "Cross-tenant storage access denial is provable: the document includes verification commands showing that Tenant A's credentials cannot access Tenant B's data in any store"
    - "The three-tier key hierarchy (age KEK -> SOPS DEK -> encrypted values) is documented with concrete file structures, CLI commands, and the control plane registry schema for key-to-tenant mapping"
  artifacts:
    - path: "docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md"
      provides: "Complete per-tenant storage namespace and encryption key management specification"
      contains: "Storage Namespace"
      min_lines: 500
  key_links:
    - from: "docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md"
      to: "docs/product/PRD.md Section 3.4"
      via: "Provisioning steps 4-7 (storage, DB, vector store, secrets) mapped to concrete commands"
      pattern: "PRD.*3\\.4|provisioning.*step"
    - from: "docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md"
      to: "docs/reference/TECH_DECISIONS.md"
      via: "References MinIO, PostgreSQL >=16, Qdrant >=1.13, Redis >=8.0, SOPS >=3.9, age >=1.2"
      pattern: "MinIO|PostgreSQL|Qdrant|Redis|SOPS|age"
    - from: "docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md"
      to: "docs/product/PRD.md Section 3.6"
      via: "Deprovisioning steps 3-5 (vector, relational, object store deletion)"
      pattern: "deprovision|delete.*collection|drop.*database|delete.*bucket"
---

<objective>
Write the complete per-tenant storage namespace isolation and encryption key management specification.

Purpose: Phase 2 requires that every stateful component has a documented isolation mechanism, credential scope, and verification method. This document specifies exactly how to provision, isolate, and encrypt per-tenant data across MinIO (object store), PostgreSQL (relational DB), Qdrant (vector store), and Redis (cache/queue), plus the SOPS + age encryption key management lifecycle -- eliminating all ambiguity about the data isolation layer.

Output: `docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` -- a standalone architecture specification document covering ISOL-02 (per-tenant storage namespaces) and ISOL-03 (encryption key management).
</objective>

<execution_context>
@/Users/coreyalejandro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coreyalejandro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 outputs (required references)

@docs/product/PRD.md (Section 3.4: Provisioning Actions Detail steps 4-7, Section 3.6: Deprovisioning steps 3-5)
@docs/reference/TECH_DECISIONS.md (Component #11: PostgreSQL >=16, #15: Qdrant >=1.13, #16: MinIO, #19: Redis >=8.0, #20: SOPS + age)

# Phase 2 research (verified patterns and pitfalls)

@.planning/phases/02-tenant-isolation-architecture/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write per-tenant storage namespace specifications for all four stores</name>
  <files>docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md</files>
  <action>
Create `docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` with the following structure and content:

**Document header:**

- Title: "Tenant Isolation: Per-Tenant Storage Namespaces and Encryption Key Management"
- Document version, created date, requirement traceability (ISOL-02, ISOL-03)
- Document conventions section: notation for CLI commands, SQL statements, API calls, and verification commands
- Storage isolation principle statement: "Every tenant gets dedicated namespaces in all stateful components. No shared tables, buckets, collections, or key prefixes across tenants. Isolation is structural (by construction), not policy-based (by filter)."

**Section 1: Storage Isolation Overview**

- Table summarizing all four stores with their isolation mechanism:

  | Store | Namespace Type | Naming Convention | Credential Scope | Isolation Mechanism |
  |-------|---------------|-------------------|------------------|---------------------|
  | MinIO | Bucket | `tenant-{tenant_id}-bucket` | IAM user + policy | Per-user IAM policy scoped to bucket ARN |
  | PostgreSQL | Database | `tenant_{tenant_id}` | Database user | Dedicated user + REVOKE CONNECT FROM PUBLIC + pg_hba.conf |
  | Qdrant | Collection | `tenant_{tenant_id}` | Application-level | Collection-per-tenant + app-level access control |
  | Redis | Key prefix | `tenant:{tenant_id}:*` | Shared instance | Key prefix convention + ACL rules (Redis >=6) |

- Mermaid diagram showing the three-store pattern from ARCHITECTURE.md: Object Store (raw documents) -> Relational DB (metadata, structured data, audit) -> Vector Store (embeddings)

**Section 2: MinIO Object Store Isolation (PRD 3.4 Step 4)**

2.1 Bucket provisioning:

- `mc mb {alias}/tenant-{tenant_id}-bucket` with complete command
- Bucket naming convention and constraints (3-63 chars, lowercase, no dots)
- Server-side encryption configuration: `mc encrypt set sse-s3 {alias}/tenant-{tenant_id}-bucket`

2.2 IAM user and policy creation:

- Generate access key and secret key (document how credentials flow to SOPS encryption -- forward reference to Section 6)
- `mc admin user add {alias} tenant-{tenant_id}-access {secret_key}`
- IAM policy JSON document -- COMPLETE, not abbreviated:
  - ALLOW: `s3:ListBucket` on `arn:aws:s3:::tenant-{tenant_id}-bucket`
  - ALLOW: `s3:GetObject`, `s3:PutObject`, `s3:DeleteObject` on `arn:aws:s3:::tenant-{tenant_id}-bucket/*`
  - Explicit DENY on all other bucket ARNs (defense in depth -- even though IAM defaults to deny, explicit deny prevents policy escalation)
- `mc admin policy create {alias} tenant-{tenant_id}-policy {policy_file}`
- `mc admin policy attach {alias} tenant-{tenant_id}-policy --user=tenant-{tenant_id}-access`
- Document research Pitfall 5: bucket policies control anonymous access only; IAM policies control authenticated user access

2.3 Bucket structure:

- Directory convention within tenant bucket:

  ```
  tenant-{tenant_id}-bucket/
    raw/                    # Original uploaded documents
    parsed/                 # Canonical JSON after parsing
    receipts/               # Intake receipts
    exports/                # Compliance evidence exports
  ```

2.4 Verification:

- `mc alias set tenant-test http://{minio_host}:9000 tenant-{tenant_id}-access {secret_key}`
- `mc ls tenant-test` -- should show only `tenant-{tenant_id}-bucket`
- `mc ls tenant-test/tenant-{other_id}-bucket` -- should fail with "Access Denied"
- `mc admin user info {alias} tenant-{tenant_id}-access` -- should show attached policy

2.5 Deprovisioning (PRD 3.6 Step 5):

- `mc rm --recursive --force {alias}/tenant-{tenant_id}-bucket` (empty bucket)
- `mc rb {alias}/tenant-{tenant_id}-bucket` (remove bucket)
- `mc admin user remove {alias} tenant-{tenant_id}-access` (remove user)
- `mc admin policy remove {alias} tenant-{tenant_id}-policy` (remove policy)
- Verification: `mc ls {alias}/tenant-{tenant_id}-bucket` returns "bucket not found"

2.6 Offline mode:

- Same MinIO instance running in Docker container
- Same provisioning commands (MinIO is identical in both modes)
- Volume mount: `minio-data:/data` in docker-compose.yml

**Section 3: PostgreSQL Relational Database Isolation (PRD 3.4 Step 5)**

3.1 Database and user provisioning:

- Complete SQL script (not abbreviated):

  ```sql
  -- 1. Create database
  CREATE DATABASE tenant_{tenant_id};

  -- 2. Create user with encrypted password
  CREATE USER tenant_{tenant_id}_user WITH ENCRYPTED PASSWORD '{password_from_sops}';

  -- 3. Grant privileges on database
  GRANT ALL PRIVILEGES ON DATABASE tenant_{tenant_id} TO tenant_{tenant_id}_user;

  -- 4. Revoke public access (CRITICAL)
  REVOKE CONNECT ON DATABASE tenant_{tenant_id} FROM PUBLIC;

  -- 5. Connect to tenant database and grant schema privileges
  \c tenant_{tenant_id}
  GRANT ALL ON SCHEMA public TO tenant_{tenant_id}_user;
  ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO tenant_{tenant_id}_user;
  ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO tenant_{tenant_id}_user;
  ```

- Explain why REVOKE CONNECT FROM PUBLIC is critical: without it, any database user can connect to any database

3.2 pg_hba.conf network restriction:

- Entry format: `host  tenant_{tenant_id}  tenant_{tenant_id}_user  10.{tenant_octet}.0.0/16  scram-sha-256`
- Explain that this restricts the tenant user to connections from the tenant's private network only
- Reload command: `SELECT pg_reload_conf();` (no restart needed for pg_hba.conf changes)
- Discuss placement order in pg_hba.conf (more specific rules first)

3.3 Verification:

- `\l` -- list databases, verify `tenant_{tenant_id}` exists
- `\du` -- list users, verify `tenant_{tenant_id}_user` has correct roles
- Connect as tenant user: `psql -h {host} -U tenant_{tenant_id}_user -d tenant_{tenant_id}` -- should succeed from tenant network
- Cross-tenant test: `psql -h {host} -U tenant_{tenant_id}_user -d tenant_{other_id}` -- should fail with "permission denied"
- Network test: connect from non-tenant network -- should fail with "no pg_hba.conf entry"

3.4 Deprovisioning (PRD 3.6 Step 4):

- Terminate active connections: `SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = 'tenant_{tenant_id}';`
- Drop database: `DROP DATABASE tenant_{tenant_id};`
- Drop user: `DROP USER tenant_{tenant_id}_user;`
- Remove pg_hba.conf entry and reload
- Verification: `\l` should not show `tenant_{tenant_id}`

3.5 Offline mode:

- Shared PostgreSQL instance in Docker container
- Same SQL provisioning commands
- pg_hba.conf: use Docker network CIDR instead of Hetzner private network CIDR

**Section 4: Qdrant Vector Store Isolation (PRD 3.4 Step 6)**

4.1 Collection provisioning:

- REST API: `PUT /collections/tenant_{tenant_id}` with complete request body:

  ```json
  {
    "vectors": {
      "size": 768,
      "distance": "Cosine"
    }
  }
  ```

- Python SDK equivalent using `qdrant_client`
- Vector dimensions locked to 768 (Phase 1 decision -- reference TECH_DECISIONS.md)

4.2 Application-level access control:

- Qdrant does not natively support API key scoping to specific collections (research Open Question 2)
- Implement tenant-to-collection mapping in the application layer:
  - Function: `get_collection_name(tenant_id: str) -> str` returns `tenant_{tenant_id}`
  - Guard function: `verify_tenant_access(tenant_id: str, collection_name: str)` raises PermissionError if mismatch
  - All Qdrant operations must pass through these guard functions
- Document that this is a defense-in-depth measure: even if the guard fails, collections are structurally separate (no vector from Tenant A exists in Tenant B's collection)

4.3 Verification:

- `GET /collections` -- list all collections, verify `tenant_{tenant_id}` exists
- Insert test vector and search -- verify results only contain tenant data
- Attempt to search wrong collection via application guard -- verify PermissionError raised

4.4 Deprovisioning (PRD 3.6 Step 3):

- Delete all points: `POST /collections/tenant_{tenant_id}/points/delete` with filter (or skip -- dropping collection removes all)
- Delete collection: `DELETE /collections/tenant_{tenant_id}`
- Verification: `GET /collections/tenant_{tenant_id}` returns 404

4.5 Offline mode:

- Same Qdrant instance in Docker container
- Same REST API provisioning commands
- Storage volume: `qdrant-data:/qdrant/storage`

**Section 5: Redis Cache/Queue Isolation (PRD 3.4 Step 7 — supplementary)**

5.1 Key prefix convention:

- All tenant keys use prefix: `tenant:{tenant_id}:`
- Examples:
  - Cache: `tenant:{tenant_id}:cache:{key}`
  - Queue: `tenant:{tenant_id}:queue:{queue_name}`
  - Rate limit: `tenant:{tenant_id}:ratelimit:{endpoint}`
  - Session: `tenant:{tenant_id}:session:{session_id}`

5.2 Redis ACL configuration (Redis >=6):

- Create per-tenant ACL user:

  ```
  ACL SETUSER tenant_{tenant_id}_user on >{password} ~tenant:{tenant_id}:* +@all -@dangerous
  ```

- This restricts the user to keys matching `tenant:{tenant_id}:*` only
- The `-@dangerous` flag blocks commands like FLUSHALL, FLUSHDB, CONFIG, DEBUG

5.3 Verification:

- `AUTH tenant_{tenant_id}_user {password}` -- authenticate as tenant user
- `SET tenant:{tenant_id}:test value` -- should succeed
- `SET tenant:{other_id}:test value` -- should fail with "NOPERM"
- `ACL GETUSER tenant_{tenant_id}_user` -- verify key pattern and permissions

5.4 Deprovisioning:

- Delete all tenant keys: `redis-cli --scan --pattern "tenant:{tenant_id}:*" | xargs redis-cli DEL`
- Remove ACL user: `ACL DELUSER tenant_{tenant_id}_user`
- Verification: `redis-cli --scan --pattern "tenant:{tenant_id}:*"` returns empty

5.5 Offline mode:

- Same Redis instance in Docker container
- Same ACL configuration
- Persistence: `redis-data:/data` volume

Important constraints:

- Every provisioning command must be complete and copy-pasteable (no ellipsis or abbreviation)
- Include both CLI/SQL format and Python SDK format where applicable
- Reference PRD Section 3.4 step numbers explicitly
- Document research Pitfall 5 (MinIO bucket policy vs IAM policy) with correct approach
- The Qdrant application-level access control section must acknowledge the limitation and provide the guard function pattern
- Redis ACL section must use Redis >=6 ACL features (confirmed by TECH_DECISIONS: Redis >=8.0)
  </action>
  <verify>
Verify the document:

1. `grep -c "MinIO\|minio\|mc " docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 15
2. `grep -c "PostgreSQL\|psql\|CREATE DATABASE\|pg_hba" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 15
3. `grep -c "Qdrant\|qdrant\|collection" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 15
4. `grep -c "Redis\|redis\|ACL" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 10
5. `grep -c "tenant_id\|tenant_{" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 30
6. `grep -c "verification\|Verification\|verify\|Verify" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 10
7. `wc -l docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 350
  </verify>

  <done>
Sections 1-5 are complete covering all four stateful components (MinIO, PostgreSQL, Qdrant, Redis) with isolation mechanism, credential scope, provisioning commands, verification methods, deprovisioning procedures, and offline mode equivalents. Cross-tenant access denial is verifiable for each store.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write encryption key management design with SOPS + age lifecycle</name>
  <files>docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md</files>
  <action>
Add the following sections to the existing `docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md`:

**Section 6: Encryption Key Management Design (ISOL-03)**

6.1 Three-tier key hierarchy:

- Diagram (Mermaid or ASCII) showing the hierarchy:

  ```
  Tier 1: age recipient key (KEK) — per-tenant asymmetric key pair
    └─> Tier 2: SOPS data key (DEK) — generated per-file, 256-bit AES, encrypted by KEK
        └─> Tier 3: Individual secret values — encrypted with AES256_GCM using DEK
  ```

- Explain each tier's purpose:
  - KEK (age key): Protects the DEK. One per tenant. Public key stored in control plane registry. Private key stored in secure control plane storage.
  - DEK (SOPS data key): Protects individual secrets in a SOPS file. Auto-generated by SOPS per encryption operation. Never stored in plaintext -- always encrypted by KEK.
  - Secret values: The actual credentials (DB passwords, API keys, MinIO credentials). Encrypted individually with AES256_GCM.
- Explain why envelope encryption: compromising a DEK exposes one file; compromising a KEK exposes all of a tenant's secrets (but not other tenants).

6.2 Key generation procedure:

- Step-by-step with complete commands:

  ```bash
  # 1. Create tenant key directory
  mkdir -p .secrets/tenants/{tenant_id}

  # 2. Generate age key pair
  age-keygen -o .secrets/tenants/{tenant_id}/key.age
  # Output includes public key: age1...

  # 3. Extract public key
  grep "public key:" .secrets/tenants/{tenant_id}/key.age | awk '{print $NF}' > .secrets/tenants/{tenant_id}/key.pub

  # 4. Store public key in control plane registry
  UPDATE tenants SET age_public_key = '{public_key}' WHERE tenant_id = '{tenant_id}';

  # 5. Set file permissions on private key
  chmod 600 .secrets/tenants/{tenant_id}/key.age
  ```

- Private key storage: explain where private keys are stored in online mode (control plane server, encrypted filesystem) vs offline mode (bundled in encrypted config)

6.3 Secrets file structure:

- Per-tenant secrets YAML before encryption:

  ```yaml
  # tenant-{tenant_id}-secrets.yaml
  minio_access_key: "tenant-{tenant_id}-access"
  minio_secret_key: "{generated_secret}"
  postgres_password: "{generated_password}"
  qdrant_api_key: "{generated_key}"
  redis_password: "{generated_password}"
  tenant_api_key: "{generated_api_key}"
  ```

- After SOPS encryption (show the encrypted format with ENC[AES256_GCM,...] values and the sops metadata block)
- .sops.yaml configuration file for the project:

  ```yaml
  creation_rules:
    - path_regex: \.secrets/tenants/([^/]+)/secrets\.enc\.yaml$
      age: # dynamically set per tenant
  ```

6.4 Encryption workflow:

- Complete command sequence:

  ```bash
  # Encrypt secrets file with tenant's age public key
  sops --age $(cat .secrets/tenants/{tenant_id}/key.pub) \
       --encrypt .secrets/tenants/{tenant_id}/secrets.yaml \
       > .secrets/tenants/{tenant_id}/secrets.enc.yaml

  # Remove plaintext secrets file
  shred -u .secrets/tenants/{tenant_id}/secrets.yaml
  ```

6.5 Decryption workflow (used by provisioning scripts and application):

- Command-line:

  ```bash
  export SOPS_AGE_KEY_FILE=.secrets/tenants/{tenant_id}/key.age
  sops --decrypt .secrets/tenants/{tenant_id}/secrets.enc.yaml
  ```

- Programmatic (Python):

  ```python
  import subprocess
  import yaml

  def decrypt_tenant_secrets(tenant_id: str) -> dict:
      result = subprocess.run(
          ["sops", "--decrypt", f".secrets/tenants/{tenant_id}/secrets.enc.yaml"],
          capture_output=True, text=True,
          env={**os.environ, "SOPS_AGE_KEY_FILE": f".secrets/tenants/{tenant_id}/key.age"}
      )
      if result.returncode != 0:
          raise RuntimeError(f"Failed to decrypt secrets for {tenant_id}: {result.stderr}")
      return yaml.safe_load(result.stdout)
  ```

**Section 7: Key Rotation Procedure**

7.1 Rotation triggers:

- Scheduled rotation: every 90 days (configurable per tenant)
- Emergency rotation: on suspected key compromise
- Personnel rotation: when an operator with key access leaves

7.2 Step-by-step rotation procedure:

- Complete commands with safety checks:

  ```bash
  # 1. Generate new age key pair
  age-keygen -o .secrets/tenants/{tenant_id}/key-new.age
  NEW_PUB=$(grep "public key:" .secrets/tenants/{tenant_id}/key-new.age | awk '{print $NF}')
  OLD_PUB=$(cat .secrets/tenants/{tenant_id}/key.pub)

  # 2. Verify decryption with old key still works (SAFETY CHECK)
  SOPS_AGE_KEY_FILE=.secrets/tenants/{tenant_id}/key.age \
    sops --decrypt .secrets/tenants/{tenant_id}/secrets.enc.yaml > /dev/null
  echo "Old key decryption: OK"

  # 3. Rotate: add new key, remove old key
  sops --rotate \
       --add-age $NEW_PUB \
       --rm-age $OLD_PUB \
       --in-place .secrets/tenants/{tenant_id}/secrets.enc.yaml

  # 4. Verify decryption with new key
  SOPS_AGE_KEY_FILE=.secrets/tenants/{tenant_id}/key-new.age \
    sops --decrypt .secrets/tenants/{tenant_id}/secrets.enc.yaml > /dev/null
  echo "New key decryption: OK"

  # 5. Archive old key for backup recovery period (90 days)
  mv .secrets/tenants/{tenant_id}/key.age .secrets/tenants/{tenant_id}/key-$(date +%Y%m%d)-archived.age

  # 6. Promote new key
  mv .secrets/tenants/{tenant_id}/key-new.age .secrets/tenants/{tenant_id}/key.age
  mv .secrets/tenants/{tenant_id}/key-new.age.pub .secrets/tenants/{tenant_id}/key.pub  # if separate pub file
  echo $NEW_PUB > .secrets/tenants/{tenant_id}/key.pub

  # 7. Update control plane registry
  UPDATE tenants SET age_public_key = '$NEW_PUB', key_rotated_at = NOW() WHERE tenant_id = '{tenant_id}';

  # 8. Emit audit event
  INSERT INTO audit_events (event_type, tenant_id, details)
  VALUES ('KEY_ROTATED', '{tenant_id}', '{"old_key_hash": "...", "new_key_hash": "..."}');
  ```

7.3 Backup recovery with archived keys (research Pitfall 3):

- Old private keys are archived (not deleted) for the backup recovery period
- If a backup from before rotation needs to be restored, the archived key is required
- Archive retention: 90 days after rotation
- Secure deletion after retention: `shred -u .secrets/tenants/{tenant_id}/key-*-archived.age`
- Key-to-backup-date mapping table in control plane registry

7.4 Emergency rotation:

- Same procedure as scheduled but with immediate old key revocation
- All active sessions using old credentials must be terminated
- All service credentials (MinIO, PostgreSQL, Qdrant, Redis) must be regenerated and re-encrypted with new key

**Section 8: Key-to-Tenant Mapping Registry**

8.1 Control plane registry schema:

- SQL schema for the tenants table key management fields:

  ```sql
  ALTER TABLE tenants ADD COLUMN age_public_key TEXT NOT NULL;
  ALTER TABLE tenants ADD COLUMN key_rotated_at TIMESTAMP WITH TIME ZONE;
  ALTER TABLE tenants ADD COLUMN key_rotation_due_at TIMESTAMP WITH TIME ZONE;
  ALTER TABLE tenants ADD COLUMN key_version INTEGER DEFAULT 1;
  ```

8.2 Key metadata tracking:

- Table: `tenant_key_history`

  ```sql
  CREATE TABLE tenant_key_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id TEXT NOT NULL REFERENCES tenants(tenant_id),
    key_version INTEGER NOT NULL,
    public_key_hash TEXT NOT NULL,  -- SHA-256 of age public key
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    archived_at TIMESTAMP WITH TIME ZONE,
    purged_at TIMESTAMP WITH TIME ZONE,
    rotation_reason TEXT  -- 'scheduled', 'emergency', 'personnel'
  );
  ```

8.3 Key status lifecycle:

- ACTIVE: Current key for encryption/decryption
- ARCHIVED: Old key retained for backup recovery (can decrypt, cannot encrypt new secrets)
- PURGED: Key securely deleted after retention period

**Section 9: Storage Isolation Verification Runbook**

9.1 Cross-store verification checklist:
For each tenant, verify:

- [ ] MinIO: tenant user can only access tenant bucket
- [ ] PostgreSQL: tenant user can only connect to tenant database
- [ ] Qdrant: application guard prevents cross-collection access
- [ ] Redis: tenant ACL user can only access tenant key prefix
- [ ] Encryption: tenant secrets file decrypts only with tenant's age key

9.2 Automated verification script pattern:

- Python script skeleton that runs all verification checks and produces a JSON report
- Report format: `{"tenant_id": "...", "checks": [{"store": "minio", "test": "cross_tenant_access", "result": "DENIED", "timestamp": "..."}]}`

9.3 Compliance evidence format:

- How verification results are stored for audit purposes
- Links to the audit system (forward reference to Phase 3)

**Section 10: Storage Provisioning Sequence (Combined)**

- Combined provisioning sequence showing the order for all four stores plus encryption:
  1. Generate age key pair (Section 6.2)
  2. Generate credentials for all stores (random passwords/keys)
  3. Create SOPS-encrypted secrets file (Section 6.4)
  4. Provision MinIO bucket and user (Section 2)
  5. Provision PostgreSQL database and user (Section 3)
  6. Provision Qdrant collection (Section 4)
  7. Provision Redis ACL user (Section 5)
  8. Run cross-store verification (Section 9)
  9. Register in tenant registry with key metadata (Section 8)
- This sequence maps to PRD 3.4 Steps 4-7 with the encryption step prepended
- Error handling: if any step fails, roll back all previously completed steps

Important constraints:

- Every command must be complete and executable (no `...` abbreviations in commands)
- Include both CLI and Python SDK formats where both exist
- The IAM policy JSON for MinIO must be complete (not truncated)
- PostgreSQL provisioning must include REVOKE CONNECT FROM PUBLIC (critical security step)
- Key rotation must include the safety check (verify old key works before rotating)
- Archive old keys for backup recovery -- do NOT immediately delete (research Pitfall 3)
- Redis ACL section leverages Redis >=6 features (consistent with TECH_DECISIONS Redis >=8.0)
  </action>
  <verify>
Verify the additions:

1. `grep -c "age-keygen\|SOPS\|sops\|age1\|envelope" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 15 (encryption lifecycle covered)
2. `grep -c "rotate\|rotation\|Rotation" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 8 (rotation procedure detailed)
3. `grep -c "KEK\|DEK\|AES256_GCM\|key hierarchy\|envelope encryption" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 5 (three-tier hierarchy documented)
4. `grep -c "backup\|archive\|archived\|recovery" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 5 (backup safety addressed)
5. `grep -c "tenant_key_history\|age_public_key\|key_version" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 3 (registry schema exists)
6. `grep -c "PRD.*3\\.4\|PRD.*3\\.6\|Section 3" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 3 (PRD cross-references)
7. `wc -l docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 500 (total document with both tasks)
8. `grep -c "mermaid\|```" docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md` returns >= 10 (code blocks and diagrams present)
  </verify>

  <done>
Sections 6-10 are complete. The three-tier key hierarchy is documented with concrete CLI commands and Python code. Key generation, encryption, decryption, and rotation procedures are step-by-step with safety checks. Key-to-tenant mapping registry schema is defined. The combined provisioning sequence orders all operations correctly. Backup recovery with archived keys is specified per research Pitfall 3.
  </done>
</task>

</tasks>

<verification>
After both tasks, verify the complete document against Phase 2 success criteria:

1. **ISOL-02 coverage:** For every stateful component (MinIO, PostgreSQL, Qdrant, Redis), the document specifies the isolation mechanism, credential scope, and verification method
2. **ISOL-03 coverage:** The encryption key management design covers key generation, envelope encryption, rotation procedure, and key-to-tenant mapping with enough detail to implement without interpretation
3. **PRD traceability:** PRD Section 3.4 steps 4-7 are mapped to concrete provisioning commands; PRD Section 3.6 steps 3-5 are mapped to deprovisioning commands
4. **Cross-tenant denial:** Each store has a verification command proving Tenant A cannot access Tenant B's data
5. **Key lifecycle completeness:** Generation -> encryption -> decryption -> rotation -> archival -> purge is documented end-to-end
6. **Offline mode parity:** Every online provisioning command has an offline mode equivalent or explicit "same" notation
</verification>

<success_criteria>

- docs/architecture/TENANT_ISOLATION_STORAGE_ENCRYPTION.md exists with >= 500 lines
- Document covers ISOL-02 (storage namespaces) and ISOL-03 (encryption key management)
- All four stores (MinIO, PostgreSQL, Qdrant, Redis) have complete provisioning, verification, and deprovisioning sections
- Three-tier key hierarchy (KEK/DEK/values) is documented with diagram
- Key rotation procedure includes safety checks and backup recovery
- Key-to-tenant mapping registry has SQL schema
- Combined provisioning sequence with error handling and rollback
- Cross-tenant access denial is verifiable for each store
</success_criteria>

<output>
After completion, create `.planning/phases/02-tenant-isolation-architecture/02-02-SUMMARY.md`
</output>
