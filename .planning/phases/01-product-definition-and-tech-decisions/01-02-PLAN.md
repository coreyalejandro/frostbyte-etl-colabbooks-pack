---
phase: 01-product-definition-and-tech-decisions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/TECH_DECISIONS.md
autonomous: true

must_haves:
  truths:
    - "Every component in the system has exactly one technology choice with a rationale — no 'choose between X and Y' language remains anywhere in the document"
    - "The online dependency manifest lists every Python package with a version floor, every Docker image with a digest or version pin, and every ML model with source and dimension count"
    - "The offline dependency manifest includes everything from the online manifest PLUS local model weights with SHA-256 hashes, ClamAV signature database, and all Docker images as saved tarballs with a total bundle size estimate"
    - "The cross-mode compatibility matrix documents every component with its online version, offline version, and whether vectors/data are transferable between modes"
    - "MinIO's maintenance mode status is explicitly acknowledged and the document contains a clear decision (continue with MinIO) with rationale and a documented migration path"
  artifacts:
    - path: "docs/TECH_DECISIONS.md"
      provides: "Complete technology decisions document with component decision table and version-pinned dependency manifests for online and offline modes"
      contains:
        - "Component decision table with one choice per component"
        - "Online mode dependency manifest (TECH-02)"
        - "Offline mode dependency manifest (TECH-03)"
        - "Cross-mode compatibility matrix"
  key_links:
    - from: "docs/TECH_DECISIONS.md component decisions"
      to: "docs/PRD.md pipeline phases"
      via: "Every pipeline phase component in the PRD has exactly one technology in this document"
      pattern: "intake gateway -> FastAPI, parsing -> Docling+Unstructured, embedding -> OpenRouter/Nomic, storage -> MinIO+PostgreSQL+Qdrant, queue -> Celery+Redis"
    - from: "docs/TECH_DECISIONS.md offline manifest"
      to: "docs/TECH_DECISIONS.md online manifest"
      via: "Offline manifest is a strict superset — includes everything online needs plus local-only dependencies"
      pattern: "every package in online manifest appears in offline manifest"
---

<objective>
Create the technology decisions document with locked-in component selections, version-pinned dependency manifests for both online and offline modes, and a cross-mode compatibility matrix.

Purpose: This document resolves every technology choice to exactly ONE answer with a rationale. All subsequent implementation plans reference this document for tool selections and version pins. It eliminates "choose between X and Y" language from the planning pack entirely. The dependency manifests are complete enough that an engineer can set up the full development environment (online) or build the air-gapped bundle (offline) using only this document.

Output: `docs/TECH_DECISIONS.md` — a comprehensive Markdown document covering TECH-01, TECH-02, and TECH-03 requirements.
</objective>

<execution_context>
@/Users/coreyalejandro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coreyalejandro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Source materials — the research has already been done. Your job is to finalize decisions.
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/phases/01-product-definition-and-tech-decisions/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write the component decision table (TECH-01)</name>
  <files>docs/TECH_DECISIONS.md</files>
  <action>
Read ALL source materials listed in the context section. The research has already been completed — STACK.md contains recommendations and 01-RESEARCH.md contains verified version pins and resolved open questions. Your job is to collapse recommendations into decisions and format them as a single authoritative document.

Create `docs/TECH_DECISIONS.md` starting with these sections:

**Document Header:**
- Title: "Technology Decisions: Frostbyte Multi-Tenant ETL Pipeline"
- A "Document Conventions" section explaining: locked-in decisions (specified by client, non-negotiable) vs. selected decisions (chosen from alternatives with rationale). All decisions are FINAL for v1.0 — no "consider" or "evaluate" language.
- Requirement traceability: TECH-01 -> Section 1, TECH-02 -> Section 2, TECH-03 -> Section 3.

**Section 1: Component Decision Table (TECH-01)**

Create a comprehensive decision table covering every system component. For EACH component, provide:

| Component | Selected Technology | Version Pin | Rationale (2-3 sentences) | Alternatives Rejected | Why Rejected |

Components to cover (collapse STACK.md recommendations into one row each):

**Client-specified (locked-in):**
1. Primary language: Python
2. Infrastructure: Hetzner Cloud
3. Document parsing (layout): Docling
4. Document parsing (chunking): Unstructured (OSS)
5. Online embeddings: OpenRouter (text-embedding-3-small, dimensions=768)
6. Offline embeddings: Nomic embed-text v1.5 (768d native)
7. Offline orchestration: Docker Compose

**Selected (with rationale from STACK.md, version pins from 01-RESEARCH.md):**
8. API framework: FastAPI >=0.115 — async-first, native OpenAPI, Pydantic v2 validation. Not Litestar (smaller ecosystem), not Django (sync-first, batteries irrelevant), not Flask (no async, no validation).
9. ASGI server: Uvicorn >=0.30 — standard FastAPI production server.
10. Data validation: Pydantic >=2.10 — raise floor from STACK.md's >=2.9 per 01-RESEARCH.md (Python 3.14 support at >=2.10). Pydantic 2.12.5 is current.
11. Relational database: PostgreSQL >=16 — RLS for defense-in-depth, JSONB for semi-structured metadata, mature backup/replication. Not MySQL (no RLS), not CockroachDB (over-engineered for per-tenant instances).
12. ORM: SQLAlchemy >=2.0.46 with `sqlalchemy[asyncio]` install target — 01-RESEARCH.md notes asyncio greenlet no longer auto-installed. Not raw SQL (unmaintainable), not Django ORM (wrong framework).
13. Async PG driver: asyncpg >=0.29 — fastest Python PG driver.
14. Migrations: Alembic >=1.13 — standard for SQLAlchemy.
15. Vector store: Qdrant >=1.13 (raise from STACK.md's >=1.12 per 01-RESEARCH.md; note 1.16 tiered multitenancy exists but collection-per-tenant is the decision for isolation-by-construction). Not pgvector (weaker at scale), not Weaviate (heavier ops), not ChromaDB (not production-ready), not Milvus (over-engineered).
16. Object storage: MinIO (latest self-hosted) — CRITICAL: acknowledge maintenance mode (Dec 2025). Decision: **continue with MinIO (Option A from 01-RESEARCH.md)**. Rationale: S3 API is stable and feature-complete for this use case; the codebase is mature; for a planning pack this is the lowest-risk choice. Document Garage (Rust, Apache 2.0) as the migration target if MinIO is abandoned entirely. All code uses boto3, making the migration zero-code-change.
17. S3 client: boto3 >=1.35 — universal S3 client, works with MinIO and any S3-compatible store.
18. Task queue: Celery >=5.6 (raise from STACK.md's >=5.4 per 01-RESEARCH.md — memory leak fixes, Python 3.13 support at 5.6.2). Not Temporal (higher ops complexity, migrate later if needed), not Airflow (scheduler model wrong for event-driven), not Dramatiq (smaller ecosystem).
19. Queue broker: Redis >=8.0 (raise from STACK.md's >=7.4 per 01-RESEARCH.md — Redis 8.4 is GA). Also used for caching and rate limiting.
20. Secrets management: SOPS >=3.9 + age >=1.2 — encrypted secrets in version control, per-tenant age keys. Migrate to Vault when dynamic rotation needed or >20 tenants. Not AWS/GCP KMS (violates sovereignty, breaks offline).
21. Reverse proxy / API gateway: Traefik (or Caddy) — lightweight, TLS termination, routing, rate limiting. Not Kong (too heavy), not AWS API Gateway (not self-hosted).
22. Structured logging: structlog >=25.1 (raise from STACK.md's >=24.4 per 01-RESEARCH.md; 25.5.0 is current).
23. Metrics: Prometheus >=3.5 (raise from STACK.md's >=2.54 per 01-RESEARCH.md — Prometheus 3.x is current; 3.5.1 is LTS).
24. Dashboards: Grafana >=11 — pairs with Prometheus and Loki.
25. Log aggregation: Loki >=3.2 — lightweight, Grafana-native. Not ELK (too resource-heavy for per-tenant VMs).
26. HTTP client: httpx >=0.27 — async, replaces requests.
27. Retry logic: tenacity >=9.0 — configurable backoff for API calls.
28. JWT handling: python-jose[cryptography] >=3.3 — tenant auth.
29. File upload handling: python-multipart >=0.0.9 — FastAPI file uploads.
30. MIME detection: python-magic >=0.4.27 — intake gateway allowlist enforcement.
31. Encryption: cryptography >=43 — per-tenant document-at-rest encryption.
32. Malware scanning: ClamAV >=1.4 (clamd sidecar container) — intake gateway. Works offline with local signature DB.
33. Hetzner SDK: hcloud >=2.10 (raise from STACK.md's >=2.2 per 01-RESEARCH.md; 2.16.0 is current).
34. Container runtime: Docker >=27
35. Prometheus instrumentation: prometheus-fastapi-instrumentator >=7.0

After the table, add a "Resolved Open Questions" section addressing each open question from 01-RESEARCH.md:

1. **MinIO maintenance mode**: Decision is Option A (pragmatic). Continue with MinIO. Garage documented as migration target. Rationale provided above.
2. **Embedding dimension alignment**: Both modes locked to 768d. Online: OpenRouter text-embedding-3-small with dimensions=768 parameter. Offline: Nomic embed-text v1.5 at native 768d. Cross-mode vector compatibility enabled.
3. **Nomic v1.5 vs v2**: Lock to v1.5. v2 MoE Ollama support "coming soon" but not confirmed. v1.5 confirmed for local inference via GPT4All. Document v2 as future upgrade path.
4. **Qdrant collection-per-tenant vs tiered multitenancy**: Collection-per-tenant. Isolation-by-construction principle means shared shards are unacceptable for regulated tenants, even with payload filtering. Tiered multitenancy is relevant for a future "shared infrastructure" tier.
  </action>
  <verify>
Read docs/TECH_DECISIONS.md Section 1 and verify:
1. Every component has exactly ONE technology choice — search for "or", "consider", "evaluate", "choose between" and confirm none exist in decision context.
2. All version floors match 01-RESEARCH.md verified versions (not the older STACK.md versions).
3. MinIO maintenance mode is explicitly acknowledged with a clear decision and rationale.
4. All 4 open questions from 01-RESEARCH.md are resolved in the "Resolved Open Questions" section.
5. Embedding dimensions are locked to 768d for both modes.
6. Cross-reference with docs/PRD.md Section 2 (Pipeline Phases): confirm every component mentioned in the pipeline phases (intake gateway, parser, embedder, vector store, relational DB, object store, queue broker, API gateway, malware scanner, secrets manager) has a corresponding row in the component decision table.
  </verify>
  <done>
Section 1 of docs/TECH_DECISIONS.md has a complete component decision table with 35 components, each with exactly one technology choice, a version pin, rationale, and rejected alternatives. All open questions from 01-RESEARCH.md are resolved. No ambiguous language remains.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write dependency manifests and compatibility matrix (TECH-02, TECH-03)</name>
  <files>docs/TECH_DECISIONS.md</files>
  <action>
Append to the existing docs/TECH_DECISIONS.md three additional sections:

**Section 2: Online Mode Dependency Manifest (TECH-02)**

Organize as a complete dependency specification that an engineer can use to set up the development environment:

**Python packages** (organized by layer, pyproject.toml format with version floors from Section 1):
```toml
[project]
requires-python = ">=3.12"

[project.dependencies]
# API layer
fastapi = ">=0.115"
uvicorn = {version = ">=0.30", extras = ["standard"]}
pydantic = ">=2.10"
pydantic-settings = ">=2.5"
python-multipart = ">=0.0.9"
python-jose = {version = ">=3.3", extras = ["cryptography"]}
httpx = ">=0.27"

# Database layer
sqlalchemy = {version = ">=2.0.46", extras = ["asyncio"]}
asyncpg = ">=0.29"
alembic = ">=1.13"

# Task queue layer
celery = {version = ">=5.6", extras = ["redis"]}
redis = ">=5.2"

# Storage layer
boto3 = ">=1.35"
qdrant-client = ">=1.13"

# Parsing layer (client-specified)
docling = ">=2.70"
unstructured = {version = ">=0.16", extras = ["all-docs"]}

# Security layer
cryptography = ">=43"
python-magic = ">=0.4.27"

# Observability layer
structlog = ">=25.1"
prometheus-fastapi-instrumentator = ">=7.0"

# Resilience layer
tenacity = ">=9.0"

# Infrastructure layer
hcloud = ">=2.10"
```

```toml
[project.optional-dependencies]
dev = [
  "pytest>=8.3",
  "pytest-asyncio>=0.24",
  "pytest-cov>=5.0",
  "ruff>=0.7",
  "mypy>=1.12",
  "pre-commit>=3.8",
]
```

**Docker images** (organized by service, with version tags — note: for production offline bundles, pin by digest @sha256:...; for the planning pack, version tags are sufficient):

| Service | Image | Version Tag | Purpose |
|---------|-------|-------------|---------|
| postgres | postgres | 16-alpine | Relational DB (governance metadata, lineage, audit) |
| redis | redis | 8-alpine | Celery broker, caching, rate limiting |
| qdrant | qdrant/qdrant | v1.13.0 | Vector store (per-tenant collections) |
| minio | minio/minio | latest | S3-compatible object storage |
| clamav | clamav/clamav | 1.4 | Malware scanning sidecar |
| traefik | traefik | v3 | Reverse proxy / API gateway |
| prometheus | prom/prometheus | v3.5.1 | Metrics collection |
| grafana | grafana/grafana | 11-oss | Dashboards and alerting |
| loki | grafana/loki | 3.2 | Log aggregation |
| promtail | grafana/promtail | 3.2 | Log shipping agent |

**ML models** (online mode):

| Model | Provider | Dimensions | Use Case |
|-------|----------|------------|----------|
| text-embedding-3-small | OpenRouter (OpenAI) | 768 (configured via dimensions parameter) | Document chunk embedding |

**Section 3: Offline Mode Dependency Manifest (TECH-03)**

Everything from Section 2 PLUS the following offline-only dependencies:

**Local ML model weights:**

| Model | Source | Version | Native Dimensions | File Format | Approximate Size | Checksum Requirement |
|-------|--------|---------|-------------------|-------------|------------------|---------------------|
| Nomic embed-text v1.5 | Hugging Face: nomic-ai/nomic-embed-text-v1.5 | v1.5 | 768 | GGUF (quantized) or full weights | ~550MB (full) / ~275MB (Q8_0 GGUF) | SHA-256 hash verified at bundle build time |
| PII/NER model (if ML-based) | spaCy en_core_web_lg or Presidio analyzer | Latest at bundle build | N/A | spaCy model package | ~750MB | SHA-256 hash verified at bundle build time |

**ClamAV signature database:**

| Component | Source | Update Mechanism | Size |
|-----------|--------|------------------|------|
| main.cvd | clamav.net/downloads | Shipped in bundle, updated via signed tarball on sneakernet | ~160MB |
| daily.cvd | clamav.net/downloads | Shipped in bundle, updated via signed tarball on sneakernet | ~120MB |
| bytecode.cvd | clamav.net/downloads | Shipped in bundle, updated via signed tarball on sneakernet | ~1MB |

**Docker images as saved tarballs:**
All images from Section 2 must be saved as `.tar` files via `docker save` and included in the offline bundle. List every image with its approximate compressed size.

**Total bundle size estimate:**
Sum all components:
- Docker images (compressed tarballs): ~4-5 GB
- ML model weights (Nomic + PII): ~1.3 GB
- ClamAV signatures: ~280 MB
- Configuration + scripts: ~10 MB
- **Estimated total: ~6-7 GB compressed**

**Offline-specific configuration:**
- Embedding routing: Nomic embed-text v1.5 container (no outbound network calls)
- Audit stream: Local append-only SQLite or PostgreSQL (no central aggregation)
- Docker network: `internal: true` (structural guarantee of no outbound connectivity)
- Monitoring: Prometheus + Grafana optional (included but not required)
- No Loki in offline mode (logs via `docker compose logs`)

**Section 4: Cross-Mode Compatibility Matrix**

Create a table documenting every component with its online version, offline version, and compatibility notes:

| Component | Online Mode | Offline Mode | Data Transferable? | Notes |
|-----------|-------------|--------------|-------------------|-------|
| API framework | FastAPI (same code) | FastAPI (same code) | N/A | Identical codebase |
| Relational DB | PostgreSQL 16 (per-tenant instance) | PostgreSQL 16 (single container) | Yes (pg_dump/pg_restore) | Schema identical |
| Vector store | Qdrant (per-tenant collection) | Qdrant (single collection) | Yes (snapshot export/import) | Both use 768d vectors |
| Object storage | MinIO (per-tenant bucket) | MinIO (single bucket) | Yes (mc mirror) | S3 API identical |
| Embeddings | OpenRouter text-embedding-3-small (768d) | Nomic embed-text v1.5 (768d) | Yes (same dimension) | Vectors are cross-compatible because both produce 768d; however, semantic similarity may differ slightly between models |
| Task queue | Celery + Redis | Celery + Redis | N/A | Identical |
| Malware scan | ClamAV (live signatures) | ClamAV (bundled signatures) | N/A | Offline signatures may lag |
| Audit stream | PostgreSQL (append-only, central) | PostgreSQL or SQLite (append-only, local) | Yes (JSON Lines export) | Export format identical |
| Monitoring | Prometheus + Grafana + Loki | Prometheus + Grafana (optional) | N/A | No Loki offline |
| Secrets | SOPS + age | SOPS + age (or static env) | N/A | Same mechanism |
| API gateway | Traefik | Not needed (single host) | N/A | Offline bundle is single-host |
| Tenant provisioning | Hetzner Cloud API | Static docker-compose.yml | N/A | Offline has exactly one tenant |
| Networking | Per-tenant Hetzner firewall rules | Docker `internal: true` network | N/A | Both achieve zero cross-tenant traffic |

**Explicit divergences** (things that work differently between modes):
1. Embedding model: Different models produce semantically similar but not identical vectors. If data migrates from offline to online (or vice versa), full re-indexing is recommended for optimal retrieval quality.
2. Audit aggregation: Online mode aggregates to a central audit plane. Offline mode keeps audit local. Export format is identical (JSON Lines), enabling import into the online audit plane if the offline bundle later connects.
3. ClamAV signatures: Offline signatures freeze at bundle build time. Online mode can update signatures. This is a documented security trade-off.
4. Log aggregation: Online uses Loki for centralized log search. Offline uses Docker log driver only. Operational logs are not the same as audit logs (audit logs are always complete in both modes).

After all 4 sections, add a "Version Pin Update Procedure" section describing how to update version pins:
1. Run a version audit script (check PyPI, Docker Hub, GitHub Releases)
2. Update the version floors in this document
3. Run the full test suite against the new versions
4. Update the offline bundle and verify hash integrity
5. Document the version change in the CHANGELOG

This ensures the manifests remain a living document, not a snapshot that rots.
  </action>
  <verify>
Read docs/TECH_DECISIONS.md Sections 2-4 and verify:

1. Online manifest (Section 2): Every Python package from Section 1 appears in the manifest with a version floor. All Docker images are listed with version tags. The ML model (OpenRouter) is documented with its dimension configuration.

2. Offline manifest (Section 3): Contains everything from Section 2. Additionally has: Nomic embed-text v1.5 with dimensions and approximate size, PII/NER model, ClamAV signature database (3 files), Docker images as tarballs, and total bundle size estimate.

3. Cross-mode compatibility matrix (Section 4): Every component appears with online version, offline version, and transferability notes. Embedding dimension alignment (768d both modes) is confirmed. Explicit divergences are documented (at least 4: embedding model, audit aggregation, ClamAV signatures, log aggregation).

4. No "choose between" or "consider" language in any manifest.

5. Total bundle size estimate is present and reasonable (should be 5-8 GB range).
  </verify>
  <done>
docs/TECH_DECISIONS.md has all 4 sections. Section 2 is a complete online dependency manifest with Python packages (pyproject.toml format), Docker images, and ML model. Section 3 is a complete offline manifest including local model weights with SHA-256 requirements, ClamAV signatures, Docker tarballs, and total bundle size estimate (~6-7 GB). Section 4 is a cross-mode compatibility matrix with explicit divergences documented. Version pin update procedure exists.
  </done>
</task>

</tasks>

<verification>
Phase 1 success criteria that this plan addresses:
4. [TECH-01] Every component has exactly one technology choice with rationale — verified by scanning Section 1 for any ambiguous language
5. [TECH-02 + TECH-03] Both manifests are version-pinned and include every Python package, Docker image, and ML model weight — verified by cross-referencing Section 1 components against Sections 2 and 3 manifests
</verification>

<success_criteria>
- docs/TECH_DECISIONS.md exists with 4 sections plus header and update procedure
- Section 1 has 35 component decisions, each with exactly one technology and a version pin
- No "choose between", "consider", "evaluate" language in any decision context
- MinIO maintenance mode explicitly acknowledged with Option A decision and Garage as migration target
- Embedding dimensions locked to 768d in both modes
- Online manifest (Section 2) lists all Python packages in pyproject.toml format, all Docker images with versions, and the OpenRouter embedding model
- Offline manifest (Section 3) is a superset of online, adding Nomic weights, ClamAV signatures, Docker tarballs, and bundle size estimate
- Cross-mode compatibility matrix (Section 4) covers every component with transferability notes
- At least 4 explicit divergences documented
- Version pin update procedure exists
</success_criteria>

<output>
After completion, create `.planning/phases/01-product-definition-and-tech-decisions/01-02-SUMMARY.md`
</output>
